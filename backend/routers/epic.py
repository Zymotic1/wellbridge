"""
Epic MyChart / SMART on FHIR router.

Endpoints:
  GET  /epic/endpoints          Search Epic's hospital/health-system directory
  GET  /epic/connect            Build & return the Epic authorization URL
  POST /epic/exchange           Exchange auth code for tokens, store them, trigger sync
  GET  /epic/status             Return the current Epic connection status
  POST /epic/sync               Re-sync patient data from Epic
  DELETE /epic/disconnect       Remove the Epic connection + tokens

The OAuth code exchange lives here (not in the callback page) so that the
code_verifier never touches the browser after callback — it is POSTed
directly from the Next.js server-side API route.
"""

import logging
from datetime import datetime, timezone, timedelta

from fastapi import APIRouter, Depends, HTTPException, Query
from pydantic import BaseModel

from middleware.tenant import get_tenant_context, TenantContext
from services.supabase_client import get_scoped_client
from services.epic_fhir_service import (
    get_endpoints,
    get_smart_config,
    build_auth_url,
    exchange_code,
    refresh_access_token,
    fetch_patient_data,
    sync_fhir_data_to_db,
    encrypt_token,
    decrypt_token,
)
from config import get_settings

settings = get_settings()
log = logging.getLogger("wellbridge.epic")
router = APIRouter(prefix="/epic", tags=["epic"])


# ── Request / Response models ─────────────────────────────────────────────────

class ConnectRequest(BaseModel):
    fhir_base_url: str
    organization_name: str
    state: str            # CSRF token generated by the frontend
    code_challenge: str   # PKCE SHA-256 challenge generated by the frontend


class ExchangeRequest(BaseModel):
    code: str
    code_verifier: str    # PKCE verifier — never leaves the server after this
    fhir_base_url: str


# ── Helpers ───────────────────────────────────────────────────────────────────

def _require_epic_configured():
    if not settings.epic_configured:
        raise HTTPException(
            status_code=503,
            detail=(
                "Epic integration is not configured. "
                "Set EPIC_CLIENT_ID and EPIC_TOKEN_ENCRYPTION_KEY in your .env file. "
                "See backend/config.py for registration instructions."
            ),
        )


async def _get_valid_token(connection: dict, db) -> str:
    """
    Return a valid access token, refreshing it if expired.
    Updates the DB row if a refresh is performed.
    """
    expires_at_str = connection.get("token_expires_at")
    is_expired = True
    if expires_at_str:
        try:
            expires_at = datetime.fromisoformat(expires_at_str.replace("Z", "+00:00"))
            is_expired = expires_at <= datetime.now(timezone.utc) + timedelta(minutes=2)
        except Exception:
            pass

    if not is_expired:
        return decrypt_token(connection["access_token_enc"])

    # Refresh
    refresh_enc = connection.get("refresh_token_enc")
    if not refresh_enc:
        raise HTTPException(status_code=401, detail="Epic session expired. Please reconnect.")

    try:
        refresh_token = decrypt_token(refresh_enc)
        smart_config = await get_smart_config(connection["fhir_base_url"])
        new_tokens = await refresh_access_token(smart_config.token_endpoint, refresh_token)
    except Exception as exc:
        raise HTTPException(
            status_code=401,
            detail=f"Failed to refresh Epic token: {exc}. Please reconnect.",
        )

    new_expires_at = (
        datetime.now(timezone.utc) + timedelta(seconds=new_tokens.expires_in)
    ).isoformat()

    db.table("epic_connections").update({
        "access_token_enc": encrypt_token(new_tokens.access_token),
        "refresh_token_enc": encrypt_token(new_tokens.refresh_token or refresh_token),
        "token_expires_at": new_expires_at,
        "updated_at": datetime.now(timezone.utc).isoformat(),
    }).eq("id", connection["id"]).execute()

    return new_tokens.access_token


# ── Endpoints ─────────────────────────────────────────────────────────────────

@router.get("/endpoints")
async def search_endpoints(
    search: str = Query("", description="Hospital or health system name to search"),
    ctx: TenantContext = Depends(get_tenant_context),
):
    """
    Search Epic's public FHIR endpoint directory.
    Returns up to 20 matching hospitals with their FHIR base URLs.
    """
    _require_epic_configured()
    try:
        results = await get_endpoints(search)
        return {"endpoints": [e.model_dump() for e in results]}
    except Exception as exc:
        log.error("epic: endpoint search failed — %s", exc)
        raise HTTPException(status_code=500, detail=str(exc))


@router.post("/connect")
async def connect(
    body: ConnectRequest,
    ctx: TenantContext = Depends(get_tenant_context),
):
    """
    Build the Epic MyChart authorization URL.

    The frontend redirects the user to this URL to initiate SMART on FHIR login.
    PKCE parameters (state, code_challenge) are generated by the frontend and
    passed here — the matching code_verifier is stored in sessionStorage.
    """
    _require_epic_configured()
    try:
        smart_config = await get_smart_config(body.fhir_base_url)
        auth_url = build_auth_url(
            smart_config=smart_config,
            state=body.state,
            code_challenge=body.code_challenge,
            fhir_base_url=body.fhir_base_url,
        )
        return {
            "auth_url": auth_url,
            "token_endpoint": smart_config.token_endpoint,
        }
    except Exception as exc:
        log.error("epic: connect failed for %s — %s", body.fhir_base_url, exc)
        raise HTTPException(status_code=500, detail=str(exc))


@router.post("/exchange")
async def exchange(
    body: ExchangeRequest,
    ctx: TenantContext = Depends(get_tenant_context),
):
    """
    Exchange the OAuth authorization code for tokens.

    Called by the frontend callback page after Epic redirects back.
    Stores encrypted tokens in epic_connections and triggers an initial data sync.
    """
    _require_epic_configured()
    try:
        smart_config = await get_smart_config(body.fhir_base_url)
        tokens = await exchange_code(
            token_endpoint=smart_config.token_endpoint,
            code=body.code,
            code_verifier=body.code_verifier,
        )
    except Exception as exc:
        log.error("epic: token exchange failed — %s", exc)
        raise HTTPException(status_code=400, detail=f"Token exchange failed: {exc}")

    patient_fhir_id = tokens.patient
    expires_at = (
        datetime.now(timezone.utc) + timedelta(seconds=tokens.expires_in)
    ).isoformat()

    # Upsert connection record
    db = get_scoped_client(ctx)
    try:
        # Look up organization name from fhir_base_url
        endpoints = await get_endpoints()
        org_name = next(
            (e.organization_name for e in endpoints if e.fhir_base_url == body.fhir_base_url),
            body.fhir_base_url,
        )

        db.table("epic_connections").upsert({
            "tenant_id": ctx.tenant_id,
            "patient_user_id": ctx.user_id,
            "organization_name": org_name,
            "fhir_base_url": body.fhir_base_url,
            "access_token_enc": encrypt_token(tokens.access_token),
            "refresh_token_enc": encrypt_token(tokens.refresh_token) if tokens.refresh_token else None,
            "token_expires_at": expires_at,
            "scope": tokens.scope,
            "patient_fhir_id": patient_fhir_id,
            "sync_status": "pending",
            "updated_at": datetime.now(timezone.utc).isoformat(),
        }, on_conflict="tenant_id,patient_user_id").execute()

        log.info("epic: stored tokens for user=%s org=%s", ctx.user_id, org_name)
    except Exception as exc:
        log.error("epic: failed to store tokens — %s", exc)
        raise HTTPException(status_code=500, detail=f"Failed to store connection: {exc}")

    # Trigger initial sync (non-blocking — return to user immediately)
    sync_result = {}
    if patient_fhir_id:
        try:
            fhir_data = await fetch_patient_data(
                fhir_base_url=body.fhir_base_url,
                access_token=tokens.access_token,
                patient_id=patient_fhir_id,
            )
            sync_result = sync_fhir_data_to_db(fhir_data, ctx.tenant_id, ctx.user_id, db)

            db.table("epic_connections").update({
                "last_sync_at": datetime.now(timezone.utc).isoformat(),
                "sync_status": "success",
                "sync_error": None,
            }).eq("tenant_id", ctx.tenant_id).eq("patient_user_id", ctx.user_id).execute()

            log.info("epic: initial sync complete for user=%s — %s", ctx.user_id, sync_result)
        except Exception as exc:
            log.error("epic: initial sync failed — %s", exc)
            db.table("epic_connections").update({
                "sync_status": "error",
                "sync_error": str(exc)[:500],
            }).eq("tenant_id", ctx.tenant_id).eq("patient_user_id", ctx.user_id).execute()

    return {
        "connected": True,
        "organization_name": org_name,
        "sync": sync_result,
    }


@router.get("/status")
async def status(ctx: TenantContext = Depends(get_tenant_context)):
    """Return the current Epic connection status for this patient."""
    db = get_scoped_client(ctx)
    try:
        result = (
            db.table("epic_connections")
            .select("organization_name, fhir_base_url, last_sync_at, sync_status, created_at")
            .eq("tenant_id", ctx.tenant_id)
            .eq("patient_user_id", ctx.user_id)
            .limit(1)
            .execute()
        )
        if result.data:
            conn = result.data[0]
            return {"connected": True, **conn}
        return {"connected": False}
    except Exception as exc:
        raise HTTPException(status_code=500, detail=str(exc))


@router.post("/sync")
async def sync(ctx: TenantContext = Depends(get_tenant_context)):
    """Re-sync patient data from Epic using the stored tokens."""
    _require_epic_configured()
    db = get_scoped_client(ctx)

    result = (
        db.table("epic_connections")
        .select("*")
        .eq("tenant_id", ctx.tenant_id)
        .eq("patient_user_id", ctx.user_id)
        .limit(1)
        .execute()
    )
    if not result.data:
        raise HTTPException(status_code=404, detail="No Epic connection found. Please connect first.")

    connection = result.data[0]

    try:
        access_token = await _get_valid_token(connection, db)
    except HTTPException:
        raise
    except Exception as exc:
        raise HTTPException(status_code=401, detail=str(exc))

    patient_id = connection.get("patient_fhir_id")
    if not patient_id:
        raise HTTPException(status_code=400, detail="No patient FHIR ID on record. Please reconnect.")

    try:
        fhir_data = await fetch_patient_data(
            fhir_base_url=connection["fhir_base_url"],
            access_token=access_token,
            patient_id=patient_id,
        )
        sync_result = sync_fhir_data_to_db(fhir_data, ctx.tenant_id, ctx.user_id, db)

        db.table("epic_connections").update({
            "last_sync_at": datetime.now(timezone.utc).isoformat(),
            "sync_status": "success",
            "sync_error": None,
        }).eq("id", connection["id"]).execute()

        return {"synced": True, "summary": sync_result}
    except Exception as exc:
        log.error("epic: sync failed — %s", exc)
        db.table("epic_connections").update({
            "sync_status": "error",
            "sync_error": str(exc)[:500],
        }).eq("id", connection["id"]).execute()
        raise HTTPException(status_code=500, detail=f"Sync failed: {exc}")


@router.delete("/disconnect")
async def disconnect(ctx: TenantContext = Depends(get_tenant_context)):
    """Remove the Epic connection and all stored tokens."""
    db = get_scoped_client(ctx)
    try:
        db.table("epic_connections").delete().eq(
            "tenant_id", ctx.tenant_id
        ).eq("patient_user_id", ctx.user_id).execute()
        return {"disconnected": True}
    except Exception as exc:
        raise HTTPException(status_code=500, detail=str(exc))
